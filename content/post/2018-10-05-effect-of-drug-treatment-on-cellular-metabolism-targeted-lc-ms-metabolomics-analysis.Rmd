---
title: Effect of drug treatment on cellular metabolism (targeted LC/MS metabolomics
  analysis)
author: Darya Akimova
date: '2018-10-05'
slug: effect-of-drug-treatment-on-cellular-metabolism-targeted-lc-ms-metabolomics-analysis
categories:
  - R
  - metabolomics
tags:
  - exploratory analysis
  - linear regression
description: ''
topics: []
output:
  blogdown::html_page:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Introduction

Metabolomics is one of the many "omics" scientific fields that have sprung up over the past years and can be broadly summarized as the study of the chemical composition of cells, tissues, and biofluids. "Chemical composition" might sound sinister, but in reality, our cells (and the cells of all living things) are a soup of small compounds such as sugars, amino acids, and many other molecules that are necessary for life. The relative levels of all of these compounds can give a readout of the health of the organism, and scientists are more and more coming to appreciate the role of small molecules in common diseases such as cancer, heart disease, and diabetes. 

This project represents one of my typical liquid chromatography-mass spectrometry (LC/MS) metabolomics analysis workflows, which involves the following:

* Exploratory data analysis - evaluating distributions, missing values, principal component analysis, visualization
* Surrogate variable analysis using the `sva` package, in order to detect and account for unexpected batch effects that appear as a result of sample preparation or other technical issues
* Linear regression on a categorical variable and on surrogate variables identified by the `sva` package, followed by statistical significance analysis, all using the `limma` package
* Visualization of data cleaned of surrogate variables (residuals)
* Some pathway analysis and interpretation of significant features 

The `Setup` section outlines the importing of packages, data, and the functions that will be used throughout this analysis. This section can be skipped using the table of contents above and referred to as needed.

I don't want to get too bogged down in the technical details of the experiment, but the most important details are: 

* Samples come from tissue culture cells, either treated or not treated with a  particular drug. The sample source determines how I will handle missing values.
* Raw instrument data has to be processed/extracted to make it amenable to analysis. There are a variety of approaches to this, including the open source `xcms` Bioconductor package, but the data analyzed here was extracted using the proprietary Agilent Profinder software and an in-house database to tentatively identify the compounds. The identifications with be used towards the end in order to draw some conclusions about the impact of the drug on cellular metabolism.  
* Another thing that will pop up throughout, is the idea of the two "positive" and "negative" mode datasets. This has to do with instrument settings and how it detects molecules. Mass spectrometers can only detect and measure charged molecules, but molecules can have either positive or negative charges. Negative mode simply means that the instrument only detects and measures negatively charged molecules, while positive mode is for positively-charged molecules. Some molecules can be measured in either mode, and the data from positive and negative mode can be used as corroborative evidence. But some molecules can only be detected in one mode or the other, which is why both datasets are needed. The methodology can vary from lab to lab, but my lab usually runs each sample at least twice, once for each instrument mode, which results in two separate datasets. 

The overall goal of the following analysis is to determine which of the compounds detected and quantified were changed in abundance after drug treatment. 


# Setup


## Packages

```{r packages, comment=NA}
library(tidyverse)  
library(cowplot)  
library(heatmaply)  
library(sva)  
library(limma) 
library(broom)
library(ggridges)
```

Reasons for use:

* tidyverse - data wrangling, plotting, other general functions
* cowplot - ggplot formatting that I like
* heatmaply - interactive heatmaps, a popular visualization format for high-dimensional omics data
* sva - surrogate variable analysis for batch effects
* limma - statistical analysis package, designed and typically used for genomics analyses (microarray studies, RNA-seq), but once the raw samples are processed, the methodologies between the two fields are similar in terms of statistical significance testing
* broom - for `lm` model tidying
* ggridges - useful for creating ridge plots to look at data distributions


## Data

There are two data files associated with this analysis:

* Abundance readings from the cells in negative MS mode
* Abundance readings from the cells in positive MS mode

Note: The abundance data collected for this experiment is "semi-quantitative", in that the abundance values highly depend on instrument state and mode. Samples within a run, such as when the samples were analyzed in negative mode, are comparable to each other. However, these readings are not directly comparable to samples analyzed at another date or time, or to the data collected in positive mode. Even abundance values for the same compound, in the same sample, are likely to not be equal between the two modes, and so the two datasets are analyzed separately. The fold change between experimental groups, however, is expected to be similar for the same compound in both datasets.

```{r import, comment=NA}
# compound abundances #
neg.raw <- read_csv("./data/cells_target_negmode.csv")
pos.raw <- read_csv("./data/cells_target_posmode.csv")
```


## Functions

Personal functions used throughout the analysis. I like to group them into one chunk at the start for organization and to make them easy to find.

```{r functions, comment=NA}
MissingPerSamplePlot <- function(raw.data, start.string) {
  # Counts the number of missing/NA values per sample and
  # percent compounds missing out of total number of compounds per sample
  # Then passes the result into a vertical bar plot, where each 
  # bar represents a single sample and the size of the bar 
  # is the % of compounds missing
  
  counted.na <- raw.data %>%
  select(starts_with(start.string)) %>% 
  mutate(
    count.na = apply(., 1, function(x) sum(is.na(x))),
    percent.na = (count.na / ncol(raw.data %>% select(starts_with(start.string)))) * 100
    ) %>%
  dplyr::select(count.na, percent.na) %>%
  bind_cols(
    raw.data %>% 
      select(Samples, Group)
      ) %>% 
  arrange(percent.na) %>% 
  mutate(f.order = factor(Samples, levels = Samples))
counted.na %>% 
  ggplot(aes(x = f.order, y = percent.na, fill = Group)) +
  geom_bar(stat = "identity") +
  geom_hline(yintercept = 20, color = "gray", size = 1, alpha = 0.8) +
  coord_flip()+
  xlab("Samples") +
  ylab("Percent missing values in sample") +
  theme(axis.text.y = element_text(size = 6)) 
}

MissingPerCompound <- function(raw.data, start.string){
  # Function to count in how many experimental samples each compound is missing
  # Also calculates the % missing:
  # (# NA per compound across all experimental samples) * 100 / (tot num of samples)
  
  raw.data %>% 
  filter(Group == "sample") %>% 
  select(Samples, starts_with(start.string)) %>% 
  gather(key = "Compound", value = "Abundance", -Samples) %>% 
  group_by(Compound) %>% 
  summarise(
    na_count = sum(is.na(Abundance)),
    n_samples = n(),
    percent_na = (na_count * 100 / n_samples)
    ) %>% 
  filter(na_count > 0) %>% 
  arrange(desc(percent_na))
}

ReplaceNAwMinLogTransform <- function(raw.dataframe, start.prefix) {
  # Function to replace any NAs in each column with the minimum for that column, 
  # separately for each sample type.
  # NA in negative control samples are replaced by 2.
  # Then data is log2 transformed
  
  smpls <- raw.dataframe %>%
    filter(Group == "sample") %>% 
    dplyr::select(starts_with(start.prefix))
  smpls.min <- lapply(smpls, min, na.rm = TRUE)
  # replace the missing values in the real samples with the minimum of the samples
  # then take the log
  smpls.noNA <- raw.dataframe  %>%
    filter(Group == "sample") %>% 
    dplyr::select(Samples:Experiment) %>%
    bind_cols(
      smpls %>%
        replace_na(replace = smpls.min) %>% 
        log2()
      )
  # replace the missing values in solv and empty samples with 2 - for PCA analysis
  # then take the log
  other.min <- setNames(
    as.list(
      rep(2, ncol(
        raw.dataframe %>% 
          dplyr::select(starts_with(start.prefix))))
      ),
    colnames(raw.dataframe %>% dplyr::select(starts_with(start.prefix)))
                )
  other.num.log <- raw.dataframe %>%
    filter(Group == "solv" | Group == "empty") %>% 
    dplyr::select(Samples:Experiment) %>%
    bind_cols(
      raw.dataframe %>% 
        filter(Group == "solv" | Group == "empty") %>% 
        dplyr::select(starts_with(start.prefix)) %>%
        replace_na(replace = other.min) %>% 
        log2()
      )
  # combine them together back into one data frame
  all.noNA <- smpls.noNA %>% 
    bind_rows(other.num.log)
}

HeatmapPrepAlt <- function(raw.data, start.prefix){
  # function for preparing dara for heatmap viz
  x <- raw.data %>% 
    select(starts_with(start.prefix)) %>% 
    scale(center = TRUE, scale = TRUE) %>% 
    as.matrix() 
  row.names(x) <- raw.data$Samples
  return(x)
}
```


# Data Exploration


## Missing Values

The number of missing values that are acceptable per sample and/or per feature can vary depending on the sample source, compound identity, and instrumentation state. I mentioned earlier that the biological origin of these datasets is tissue culture cells. This tends to be a material-rich source and a high missing-value count could indicate a problem with the sample preparation or an instrument error, both of which would be reasonable cause to exclude samples or features from further analysis. The threshold of >= 20% missing seems reasonable to me, which is what I use here.

Q: Do any of the samples have greater than 20% missing (NA) compound abundances, out of all of the features in the dataset?

```{r missing_per_sample_plots, comment=NA}
MissingPerSamplePlot(neg.raw, "ANPnC") +
  ggtitle("Missing Per Sample\nPost Drug Treatment\nNeg Mode")
MissingPerSamplePlot(pos.raw, "ANPpC") +
  ggtitle("Missing Per Sample\nPost Drug Treatment\nPos Mode")
```

A: No, sample files across both datasets have very few missing values. The green-colored bars, marked "sample" are the actual experimental samples. Whereas the "solv", or "solvent", and "empty" samples are negative control samples that are expected to have many missing values and/or low compound abundances. They will be used to narrow down the list of features later on in the analysis.

Q: Are any of the compounds more than 20% missing in the experimental sample group? If there are any, they will be excluded from analysis. 

Note: The `MissingPerCompound` function considers only the `Group == "sample"` samples.

```{r percent_missing_per_compound, comment=NA}
MissingPerCompound(neg.raw, "ANPnC") %>% 
  filter(percent_na > 20)
(pos.cmpnd.to.excl <- MissingPerCompound(pos.raw, "ANPpC") %>% 
  filter(percent_na > 20))
```

A: No compounds need to be excluded from the negative mode dataset, but 1 compound will be excluded from the positive mode dataset. 


## Negative Controls and Compound Elimination

### Background

The term negative control should not be confused with the negative/positive terminology used throughout to refer to the datasets. 

Good experimental design often involves including certain types of samples known as negative and positive controls. Positive controls are samples where you know for sure that whatever you're measuring is present, and are a verification that the instrument can detect and measure your target as expected. Negative controls, on the other hand, are used to make sure that the signal of interest is real and not an artifact of the detection or sample preparation method. 

In the case of this analysis, there are no positive controls, but there are two sets of negative controls: 

* `solv`: These are "solvent" samples - samples of just the chemical solvent that the biological samples are dissolved in for instrument analysis. Any compounds detected in these samples are probably artifacts from experimental tools themselves, such as the sample vials or plastic pipettes.
* `empty`: This group of samples is derived by treating tissue culture wells the same as the experimental cell samples, but these had no actual cells grown in them. These samples are a control for the preparation process. Cells are typically grown in very nutrient-rich liquid broth/media that is hard to get rid of completely. If any compound is present in high abundance in these "empty" samples, it may be a sigh of technical variation that can obscure biological variation.

Note: Metabolomics measurements tend to have a right-skew, with many lower values and a few very high values that tend to stretch the distribution out. The data is often log transformed to normalize it, and throughout this analysis, I use log2 transformation because that is the format expected by the `limma` package.

### Negative Mode


```{r empty_solv_neg, comment=NA}
# get the mean abundance of each compound, grouped by solvent vs empty sample vs experimental sample
neg.raw.grp.mean <- neg.raw %>% 
  group_by(Group) %>% 
  summarize_at(vars(matches("ANPnC")), mean, na.rm = TRUE) %>% 
  gather(key = "Compound", value = "Grp_mean_abun", -Group)
# plot the log2 density distribution of the means
neg.raw.grp.mean %>% 
  ggplot(aes(log2(Grp_mean_abun), color = Group)) +
  geom_density(size = 2, alpha = 0.8) +
  ggtitle("Distribution of compound means\nNegative Mode\nGrouped by sample type")
```

The distributions of the means are fairly close to normal and, in general, the compound means for the two negative control groups are lower than the experimental group means, although there is some overlap.

A profile plot of the group means for each compound is a helpful tool to visualize the data:

```{r empty_solv_neg_cont, comment=NA}
# for plotting purposes, to make the plot neater
neg.raw.grp.mean.order <- neg.raw.grp.mean %>% 
  filter(Group == "sample") %>% 
  arrange(Grp_mean_abun)
neg.raw %>% 
  select(Samples, Group, starts_with("ANPnC")) %>% 
  gather("Compound", value = "Abundance", -c(Samples, Group)) %>% 
  mutate(Cmpnd_sort = factor(Compound, levels = neg.raw.grp.mean.order$Compound)) %>% 
  ggplot(aes(Cmpnd_sort, log2(Abundance), color = Group, group = Samples)) + 
  geom_line(alpha = 0.1, size = 1) + 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  xlab("Compound") +
  # overlay the group averages 
  geom_line(
    data = neg.raw.grp.mean %>% 
      mutate(Cmpnd_sort = factor(Compound, levels = neg.raw.grp.mean.order$Compound)), 
    aes(Cmpnd_sort, log2(Grp_mean_abun), color = Group, group = Group),
    size = 0.5
    ) +
  ggtitle("Profile Plot of all compound abundances\nWith average per sample type overlaid\nNegative Mode")
# compound mean by group only, ordered by increasing abundance in the experimental samples
neg.raw.grp.mean %>% 
  mutate(Cmpnd_sort = factor(Compound, levels = neg.raw.grp.mean.order$Compound)) %>% 
  ggplot(aes(Cmpnd_sort, log2(Grp_mean_abun), color = Group, group = Group)) +
  geom_point(size = 1, alpha = 0.8) +
  geom_line(alpha = 0.8) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  xlab("Compound") +
  ylab("log2(Sample Type Mean)") +
  ggtitle("Profile Plot of compound means by sample type only\nNegative Mode")
```


The compound means of the experimental samples are compared above to both types of negative controls. Hopefully, it is possible to see in the plots that, for some compounds, the abundance in the "empty" samples exceeds the experimental samples. This is an indication that there was a high amount of carryover of that compound from the media and that these compounds should be excluded from the analysis. 

Note that the experimental sample mean was taken across treatments (drug-treated and not treated) in an attempt to reduce bias at this stage by cherry picking features inappropriately. 

It might also be useful to compare the two negative control groups to each other by normalizing to the experimenal group:

```{r empty_solv_diff_neg, comment=NA}
neg.raw.grp.diff <- neg.raw.grp.mean %>% 
  spread(Group, Grp_mean_abun) %>% 
  mutate(
    smpl_empty_diff = sample / empty,
    smpl_solv_diff = sample / solv
    )
# plot the two negative controls against each other:
neg.raw.grp.diff %>% 
  ggplot(aes(log2(smpl_empty_diff), log2(smpl_solv_diff))) +
  geom_point(size = 2, alpha = 0.5) +
  xlim(-3, 13.5) +
  ylim(-3, 13.5) +
  # abline in pink
  geom_abline(intercept = 0, slope = 1, color =  "#CC79A7", size = 2, alpha = 0.6) +
  # lm line in green
  geom_smooth(method = "lm", color = "#009E73", size = 2, alpha = 0.6, se = FALSE) +
  xlab("log2([Sample Compound Mean] / [Empty Compound Mean])") +
  ylab("log2([Sample Compound Mean] / [Solvent Compound Mean])") +
  ggtitle("Background signal\nRaw Data / Cells / Neg Mode")
# include compounds with FC > 2.5 or FC is NA (indication of NA in solv or empty)
neg.cmpnd.to.incl <- neg.raw.grp.diff %>% 
  filter((smpl_solv_diff > 2.5 & smpl_empty_diff > 2.5) | is.na(smpl_solv_diff) | is.na(smpl_empty_diff))
# how many compound were there in the raw negative mode dataset?
nrow(neg.raw.grp.diff)
# how many compounds are retained for further analysis?
nrow(neg.cmpnd.to.incl)
```

Interestingly, there seems to be a linear relationship between the two types of negative controls, although the signal to noise ratio tends to be higher in the solvent comparison versus the empty sample comparison.  

The cut-off of 2.5 is arbitrary. It's twice the fold-change cut-off that I will use as a threshold later for the treatment comparison, and I plan to repeat this experiment to test if the results are reproducible, so this feels like a comfortable threshold. In the end, 179 out of the 211 features from this set will be included in the final analysis.


### Positive Mode

The same procedure as above can be applied to the positive mode data, but I'm only going to show the results because the code is redundant.


```{r empty_solv_cell_pos, comment=NA, echo=FALSE}
pos.raw.grp.mean <- pos.raw %>% 
  group_by(Group) %>% 
  summarize_at(vars(matches("ANPpC")), mean, na.rm = TRUE) %>% 
  gather(key = "Compound", value = "Grp_mean_abun", -Group)
pos.raw.grp.mean %>% 
  ggplot(aes(log2(Grp_mean_abun), color = Group)) +
  geom_density(size = 2, alpha = 0.8) +
  ggtitle("Distribution of compound means\nPositive Mode\nGrouped by sample type")
pos.raw.grp.mean.order <- pos.raw.grp.mean %>% 
  filter(Group == "sample") %>% 
  arrange(Grp_mean_abun)
pos.raw.grp.mean %>% 
  mutate(Cmpnd_sort = factor(Compound, levels = pos.raw.grp.mean.order$Compound)) %>% 
  ggplot(aes(Cmpnd_sort, log2(Grp_mean_abun), color = Group, group = Group)) +
  geom_point(size = 1, alpha = 0.8) +
  geom_line(alpha = 0.8) +
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) +
  xlab("Compound") +
  ylab("log2(Sample Type Mean)") +
  ggtitle("Profile Plot of compound means by sample type only\nPositive Mode")
pos.raw.grp.diff <- pos.raw.grp.mean %>% 
  spread(Group, Grp_mean_abun) %>% 
  mutate(
    smpl_empty_diff = sample / empty,
    smpl_solv_diff = sample / solv
    )
pos.raw.grp.diff %>% 
  ggplot(aes(log2(smpl_empty_diff), log2(smpl_solv_diff))) +
  geom_point(size = 2, alpha = 0.5) +
  xlim(-1, 15) +
  ylim(-1, 15) +
  geom_abline(intercept = 0, slope = 1, color =  "#CC79A7", size = 2, alpha = 0.6) +
  geom_smooth(method = "lm", color = "#009E73", size = 2, alpha = 0.6, se = FALSE) +
  xlab("log2([Sample Compound Mean] / [Empty Compound Mean])") +
  ylab("log2([Sample Compound Mean] / [Solvent Compound Mean])") +
  ggtitle("Background signal\nRaw Data / Cells / Pos Mode")
# include compounds with FC > 2.5 or FC is NA (indication of NA in solv or empty)
pos.cmpnd.to.incl <- pos.raw.grp.diff %>% 
  filter((smpl_solv_diff > 2.5 & smpl_empty_diff > 2.5) | is.na(smpl_solv_diff) | is.na(smpl_empty_diff)) %>% 
  filter(!(Compound %in% pos.cmpnd.to.excl$Compound))
```

```{r comment=NA}
# how many compound were there in the raw negative mode dataset?
nrow(pos.raw.grp.diff)
# how many compounds are retained for further analysis?
nrow(pos.cmpnd.to.incl)
```

The positive mode data is very similar to the negative mode data, and about the same portion of metabolites is retained after filtering based on background noise. 


# Data Prep and Preliminary Analysis


## Cleanup

Both datasets will be prepared for downstream analysis in the following way:

* Exclude compounds that have a >20% NA across samples
* Exclude compounds that have a low signal-to-noise ratio in comparison to the negative controls (previous section)
* The missing values (NA) in the experimental samples will be replaced with the minimum for that group and by 2 for the solvent and empty samples, and then the values will be log2() transformed


```{r min_na_rpl_log_transform, comment=NA}
neg.noNA <- neg.raw %>% 
  select(Samples:Experiment, one_of(neg.cmpnd.to.incl$Compound)) %>% 
  ReplaceNAwMinLogTransform("ANPnC")
pos.noNA <- pos.raw %>% 
  select(Samples:Experiment, one_of(pos.cmpnd.to.incl$Compound)) %>% 
  ReplaceNAwMinLogTransform("ANPpC")
```


## Distribution Plots

The following section isn't the most exciting, but these plots can be helpful in detecting any problem samples after the cleanup step. 

### Negative Mode

```{r distribution_plots_neg, comment=NA}
# convert the wide format to long for plotting
neg.noNA.gathered <- neg.noNA %>% 
  gather(
    key = "Metabolite", "Abundance", 
    which(colnames(neg.noNA) == "ANPnC1"):ncol(neg.noNA)
    )
# plot all abundances in a sample, grouped by sample as a boxplot
neg.noNA.gathered %>% 
  ggplot(aes(Samples, Abundance, fill = Group)) +
  geom_boxplot() +
  geom_boxplot(aes(color = Group), fatten = NULL, fill = NA, coef = 0, outlier.alpha = 0, show.legend = FALSE) +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab("log2(Abundance)") +
  ggtitle("Boxplot of compound abundances\nAll samples\nNegative Mode")
# same data format, but as ridge plots
neg.noNA.gathered %>% 
  ggplot(aes(y = Samples, x = Abundance, fill = Group)) + 
  geom_density_ridges(scale = 15) +
  theme_ridges() +
  scale_y_discrete(expand = c(0.01, 0)) +
  ggtitle("Ridge plot of compound abundances\nAll samples\nNegative Mode")
# experimental samples only
neg.noNA.gathered %>% 
  filter(Group == "sample") %>% 
  ggplot(aes(y = Samples, x = Abundance, fill = Treatment)) + 
  geom_density_ridges(scale = 10) +
  theme_ridges() +
  scale_y_discrete(expand = c(0.01, 0)) +
  ggtitle("Ridge plot of compound abundances\nExperimental samples only\nNegative Mode")
# overlay the distributions for another look
neg.noNA.gathered %>%
  filter(Group == "sample") %>% 
  ggplot(aes(Abundance, group = Samples, color = Treatment)) +
  geom_density(alpha = 0.8, size = 0.75) +
  xlab("log2(Abundance)") +
  ggtitle("Density plot of compound abundances\nExperimental samples only\nNegative Mode")
```

Above are a couple of different ways of visualizing the data distributions. Overall, although the log-transformed data is not perfectly normal, there does not appear to be any serious issues.


### Positive Mode

Repeat the above for the second dataset. The code is basically the same as the section above, so I will only include the plots. 

```{r distribution_plots_pos, comment=NA, echo=FALSE}
pos.noNA.gathered <- pos.noNA %>% 
  gather(
    key = "Metabolite", "Abundance", 
    which(colnames(pos.noNA) == "ANPpC1"):ncol(pos.noNA)
    )
pos.noNA.gathered %>% 
  ggplot(aes(Samples, Abundance, fill = Group)) +
  geom_boxplot() +
  geom_boxplot(aes(color = Group), fatten = NULL, fill = NA, coef = 0, outlier.alpha = 0, show.legend = FALSE) +
  theme(axis.text.x = element_text(angle = 90)) +
  ylab("log2(Abundance)") +
  ggtitle("Boxplot of compound abundances\nAll samples\nPositive Mode")
pos.noNA.gathered %>% 
  ggplot(aes(y = Samples, x = Abundance, fill = Group)) + 
  geom_density_ridges(scale = 15) +
  theme_ridges() +
  scale_y_discrete(expand = c(0.01, 0)) +
  ggtitle("Ridge plot of compound abundances\nAll samples\nPositive Mode")
pos.noNA.gathered %>% 
  filter(Group == "sample") %>% 
  ggplot(aes(y = Samples, x = Abundance, fill = Treatment)) + 
  geom_density_ridges(scale = 10) +
  theme_ridges() +
  scale_y_discrete(expand = c(0.01, 0)) +
  ggtitle("Ridge plot of compound abundances\nExperimental samples only\nPositive Mode")
pos.noNA.gathered %>%
  filter(Group == "sample") %>% 
  ggplot(aes(Abundance, group = Samples, color = Treatment)) +
  geom_density(alpha = 0.8, size = 0.75) +
  xlab("log2(Abundance)") +
  ggtitle("Density plot of compound abundances\nExperimental samples only\nPositive Mode")
```

The positive mode experimental samples look more bimodal, in terms of distribution shape. There was a hint of this in the density plot of compound means in the previous section, before missing value replacement. I'm not sure what might be the reason behind this.


## Principal Component Analysis 


### Background

Principal component analysis (PCA) is used commonly in "omics" experiments as a dimension reduction technique to visualize relationships in high dimensional data. There are far more detailed explanations of this machine learning technique available elsewhere, but in brief, it extracts the shared variance between compounds across samples and combines the information into a far smaller number of new variables, or principal components. Often, compounds, genes, or other features will tend to correlate with each other, and the relationship can be simplified through PCA with some loss of information, but at the advantage of ease of visualization and a better understanding of the underlying data structure. In some cases, PCA can be used to discover unexpected or unwanted structure in the data, which can be introduced as covariates in the downstream analysis. 

### Negative Mode

```{r pca_neg, comment=NA}
# PCA on all Samples #
neg.full.pca <- neg.noNA %>% 
  select(starts_with("ANPnC")) %>% 
  # good idea to center data before pca, but scaling should not be necessary
  mutate_all(scale, center = TRUE, scale = FALSE) %>% 
  as.matrix() %>% 
  prcomp()
# plot variance explained by each new principal component
plot(
  (neg.full.pca$sdev ^ 2) * 100 / sum(neg.full.pca$sdev ^ 2), 
  xlab = "Principal Component",
  ylab = "Variance Explained",
  main = "Percent variance explained by each principal component\nAll samples only\nNegative Mode",
  type = "b"
  )
```

PCA analysis can result in a large number of components, but typically only the first few provide useful information. A plot such as the one above can be used to determine how many to keep by looking for an "elbow" in the plot of variance explained vs principal component. 

Q: For the principal component analysis on the full dataset, the first principal component accounts for approximately 90% of the variance in the data, but is this meaningful? 

```{r pca_full_neg_cont, comment=NA}
neg.full.pca.x <- as.data.frame(neg.full.pca$x)
row.names(neg.full.pca.x) <- neg.noNA$Samples
neg.full.pca.x <- neg.full.pca.x %>% 
  bind_cols(neg.noNA %>% select(Group:Experiment))
neg.full.pca.x %>% 
  ggplot(aes(x = PC1, y = PC2, color = Group)) +
  geom_point(size = 4, alpha = 0.8) +
  xlab("PC1 (90.4% Var)") +
  ylab("PC2 (3.3%)") +
  ggtitle("Principal Component Analysis\nAll Samples\nNegative Mode")
```

A: No, the first principal component is a good example of how PCA analysis can capture data structure that has nothing to do with experimental interventions. In this case, the negative controls and the experimental samples are separated along the x-axis, which is not surprising because of the difference in signal between the two groups. It goes to show that just because a PC explains a high portion of variance, does not mean that it is meaningful.

Q: What about a PCA on the experimental samples only, what does the result look like then?

```{r pca_neg_smpl, comment=NA}
# Experimental Samples Only #
neg.smpl.pca <- neg.noNA %>% 
  filter(Group == "sample") %>% 
  select(starts_with("ANPnC")) %>% 
  mutate_all(scale, center = TRUE, scale = FALSE) %>% 
  as.matrix() %>% 
  prcomp()
plot(
  (neg.smpl.pca $sdev ^ 2) * 100 / sum(neg.smpl.pca $sdev ^ 2), 
  xlab = "Principal Component",
  ylab = "Variance Explained",
  main = "Percent variance explained by each principal component\nExperimental samples only\nNegative Mode",
  type = "b"
  )
```

A: When only the experimental samples are considered, the drop-off of variance explained by principal components is far more gradual. In such a situation, anywhere between the first four to seven components might be meaningful.

Here are some plots of the results:

```{r pca_neg_smpl_cont, comment=NA}
neg.smpl.pca.x <- as.data.frame(neg.smpl.pca$x)
neg.smpl.pca.x <- neg.smpl.pca.x %>% 
  bind_cols(
    neg.noNA %>% 
      filter(Group == "sample") %>% 
      select(Samples, Group:Experiment)
  )
row.names(neg.smpl.pca.x) <- neg.smpl.pca.x$Samples
neg.smpl.pca.x %>% 
  ggplot(aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point(size = 4, alpha = 0.8) +
  xlab("PC1 (34.3% Var)") +
  ylab("PC2 (23.8%)") +
  ggtitle("Principal Component Analysis\nExperimental samples only\nNegative Mode")
neg.smpl.pca.x %>% 
  ggplot(aes(x = PC3, y = PC4, color = Treatment)) +
  geom_point(size = 4, alpha = 0.8) +
  xlab("PC3 (16.6% Var)") +
  ylab("PC4 (7.1%)") +
  ggtitle("Principal Component Analysis\nExperimental samples only\nNegative Mode")
```

After the negative controls are removed, the resulting principal components are far more informative and suggest that there might be real differences between the control group (that was not treated) and the drug-treated group, even though the separation is not perfect. There is more that can be done with the principal components, such as looking at variable loadings, but because I will be conducting testing for statistical significance later, I will stop at visualization. 


### Postive Mode

A quick visualization of the principal components for the positive mode data, experimental samples only:

```{r pca_pos, comment=NA, echo=FALSE}
pos.smpl.pca <- pos.noNA %>% 
  filter(Group == "sample") %>% 
  select(starts_with("ANPpC")) %>% 
  mutate_all(scale, center = TRUE, scale = FALSE) %>% 
  as.matrix() %>% 
  prcomp()
plot(
  (pos.smpl.pca $sdev ^ 2) * 100 / sum(pos.smpl.pca $sdev ^ 2), 
  xlab = "Principal Component",
  ylab = "Variance Explained",
  main = "Percent variance explained by each principal component\nExperimental samples only\nPositive Mode",
  type = "b"
  )
pos.smpl.pca.x <- as.data.frame(pos.smpl.pca$x)
pos.smpl.pca.x <- pos.smpl.pca.x %>% 
  bind_cols(
    pos.noNA %>% 
      filter(Group == "sample") %>% 
      select(Samples, Group:Experiment)
  )
row.names(pos.smpl.pca.x) <- pos.smpl.pca.x$Samples
pos.smpl.pca.x %>% 
  ggplot(aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point(size = 4, alpha = 0.8) +
  xlab("PC1 (57.5% Var)") +
  ylab("PC2 (19.6%)") +
  ggtitle("Principal Component Analysis\nExperimental samples only\nPositive Mode")
pos.smpl.pca.x %>% 
  ggplot(aes(x = PC3, y = PC4, color = Treatment)) +
  geom_point(size = 4, alpha = 0.8) +
  xlab("PC3 (7.2% Var)") +
  ylab("PC4 (4.7%)") +
  ggtitle("Principal Component Analysis\nExperimental samples only\nPositive Mode")
```

The result of the positive mode dataset PCA analysis is very similar to the negative mode dataset analysis. There can sometimes be instrument issues, for example, that can result in a data structure that appears in one mode, but not the other. This is not the case in this experiment, which means that we can finally stop dawdling around and get to the meaty significance testing. 


# Batch Effects and Signifiance Testing


Batch effects, or variation due to technical sources such as handling or reagents, are a common problem in scientific research, especially in high-throughput "omics" experiments. They can lead to both false positives, or the illusion of an effect of an intervention when there is none, and to false negatives, or the erroneous conclusion that there is no effect when there really is one. An excellent discussion of batch effects in biological research and potential solutions can be found in this [open source article by *Jeffrey T. Leek et al*](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3880143/). One statistical correction method, that I've adopted as well, is [surrogate variable analysis (SVA)](https://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.0030161), introduced by Jeffrey T. Leek and John D. Storey in 2007. SVA makes use of the data itself in order to estimate hidden unwanted sources of variation, which can then be used as covariates in statistical analysis or to "clean" the data.


## Negative Mode

### Surrogate variable analysis

Here, I largely follow the [sva tutorial](https://bioconductor.org/packages/release/bioc/html/sva.html):

```{r neg_sva, comment=NA}
# select only the experimental samples
neg.smpl.data <- neg.noNA %>% 
    filter(Group == "sample")
# convert to matrix format
neg.data.for.sva <- as.matrix(
  neg.smpl.data[, which(
    colnames(neg.smpl.data) == "ANPnC1"
    ):ncol(neg.smpl.data)]
  )
row.names(neg.data.for.sva) <- neg.smpl.data$Samples
# sva and limma both expect a data format with samples on the columns and features on the rows:
neg.data.for.sva <- t(neg.data.for.sva)
# phenotype prep (accounted for experimental variation)
neg.data.pheno <- as.data.frame(neg.smpl.data[, 5:7])
row.names(neg.data.pheno) <- neg.smpl.data$Samples
# full model matrix, that includes the intercept and the treatment variable:
neg.mod.drug <- model.matrix(~ as.factor(Treatment), data = neg.data.pheno)
head(neg.mod.drug)
# null model, which only includes the intercept
neg.mod0 <- model.matrix(~ 1, data = neg.data.pheno)
head(neg.mod0)
# surrogate variable estimation
neg.sv <- sva(neg.data.for.sva, neg.mod.drug, neg.mod0)
# structure of the result:
glimpse(neg.sv)
```

The `sva` function accepts the transposed data (in matrix format), and two model matrices: the null model and the full model, which should include any variables of interest. The intercept term is `1` for all samples to capture the base or control level of metabolite abundance. The second column in the full model is the Treatment term, which is `0` for control samples and `1` for the drug-treated samples. This second term is there to capture any change in metabolite abundance after drug treatment, as compared to the control level. SVA then attempts to extract any hidden data structure not accounted for by the provided variables. 


### Significance Testing

The above section might sound suspiciously like linear regression, even if you're not familiar with this type of analysis. And indeed it is! Your typical academic lives and dies by their t-tests and p-values, but in fact, t-tests (and many other statistical tests), are a special case of linear regression on a categorical variable in one form or another. Which means that covariates can be readily incorporated and accounted for without too much trouble. 

I mentioned earlier that surrogate variables could also be used to "clean" data by regressing the features of interest onto the variables, taking the residuals, and then going on with other analysis (or use ComBat to directly adjust the data). However, the `sva` user manual and other sources recommend that the covariate approach as is the correct method to go to keep the degrees of freedom straight in the statistical analysis. Cleaning data should be perfectly okay for data visualization further on.

```{r neg_stat_testing, comment=NA}
# extract the surrogate variables
neg.surr.var <- as.data.frame(neg.sv$sv)
colnames(neg.surr.var) <- c("S1", "S2", "S3")
colnames(neg.mod.drug) <- c("cntrl", "DRUGvsCNTRL")
# combine the full model matrix and the surrogate variables into one
neg.d.sv <- cbind(neg.mod.drug, neg.surr.var)  
head(neg.d.sv)
neg.top.table <- neg.data.for.sva %>% 
  # fit a linear model 
  lmFit(neg.d.sv) %>% 
  # calculate the test statistics
  eBayes() %>% 
  # select the top features that have a p-value < 0.05 after Bonferroni multiple hypothesis correction
  topTable(coef = "DRUGvsCNTRL", adjust = "bonferroni", p.value = 0.05, n = nrow(neg.data.for.sva))
# what the result looks like:
head(neg.top.table)  
# let's make it more meaningful
neg.top.w.info <- neg.top.table %>%
  rownames_to_column("compound_short") %>% 
  mutate(
    # limma's logFC is base 2, so to get the raw FC out:
    drug_div_cntrl = round(2 ^ logFC, 2),
    # for ease of interpretation:
    change_w_drug = ifelse(drug_div_cntrl < 1, "down", "up")
    ) %>% 
  # cut-off for "biologically meaningful" change - arbitrary
  filter(drug_div_cntrl > 1.2 | drug_div_cntrl < 1 / 1.2) %>%  
  arrange(change_w_drug, desc(drug_div_cntrl))
# full list of hits: 
neg.top.w.info %>% 
  select(compound_short, change_w_drug, drug_div_cntrl)
```  

The final result is that 38 compounds were found to be statistically significant with a p-value < 0.05 after multiple hypothesis testing correction, with a fold change cut-off of about 20% between the control and drug-treated groups. Out of those, 13 of the compounds were higher in the drug-treated group and 25 were lower in abundance. 

Fold changes are nice, but nothing beats some data visualization, so let's clean the data of the surrogate variables the `tidyverse` way, with nested models. The following approach could have also been used for statistical testing, but `limma` provides a few advantages, such as variance pooling across features and speed through matrix operations. The latter isn't necessarily a problem in this case because I'm working with a relatively small number of features, but it's a big advantage for analyses that might include tens of thousands of compounds or genes.

```{r fig.width = 8, fig.height=10, comment=NA}
neg.gathered <- neg.noNA %>%
  filter(Group == "sample") %>% 
  bind_cols(neg.surr.var) %>% 
  select(Samples, Treatment, S1:S3, starts_with("ANPnC")) %>% 
  gather(key = "Compound", value = "Abundance", ANPnC1:ANPnC99)
# structure so far:
glimpse(neg.gathered)
neg.nested <- neg.gathered %>% 
  group_by(Compound) %>% 
  nest() %>% 
  # apply a linear model to each individual compound, as a function of the surrogate variables
  mutate(model = map(data, ~lm(Abundance ~ S1 + S2 + S3, data = .))) %>% 
  # use broom to tidy up the output
  mutate(augment_model = map(model, augment))
# result to far:
neg.nested
# now to get the residuals out for each compound
neg.modSV.resid <- neg.nested %>% 
  unnest(data, augment_model) %>% 
  select(Samples, Treatment, Compound, .resid) %>% 
  # return to long format
  spread(Compound, .resid) 
glimpse(neg.modSV.resid[, 1:5])
# heatmap of the result:
neg.modSV.resid %>% 
  select(Samples, one_of(neg.top.w.info$compound_short)) %>% 
  # converts data to matrix, centers and scales it within each column
  HeatmapPrepAlt("ANPnC") %>% 
  t() %>% 
  heatmaply(
    colors = viridis(n = 10, option = "magma"), 
    xlab = "Samples", ylab = "Compounds",
    main = "Statistically significant compounds\nNegative Mode",
    margins = c(50, 50, 75, 30),
    k_col = 2, k_row = 2
    )
``` 

Clustering heatmaps are a popular visualization tool in bioinformatics. Clustering on high-dimensional data can be problematic because of the curse of dimensionality, but it is handy for showing all of the data when possible. Here, there are clearly 2 main clusters of samples, with the drug-treated sample branches colored in pink and the control sample branches in blue at the top. There are two major clusters of compounds as well, with the branches on the rows colored in blue for the compounds that are decreased in abundance in the drug-treated samples, and increased in abundance for the pink-colored compounds.

  
## Positive Mode

The process the same for the positive mode dataset, so I will again only include the results here:

```{r cell_pos_stat, comment = NA, echo = FALSE}
pos.smpl.data <- pos.noNA %>% 
    filter(Group == "sample")
pos.data.for.sva <- as.matrix(
  pos.smpl.data[, which(
    colnames(pos.smpl.data) == "ANPpC1"
    ):ncol(pos.smpl.data)]
  )
row.names(pos.data.for.sva) <- pos.smpl.data$Samples
pos.data.for.sva <- t(pos.data.for.sva)
# pheno prep
pos.data.pheno <- as.data.frame(pos.smpl.data[, 4:6])
row.names(pos.data.pheno) <- pos.smpl.data$Samples
# sva calculation
pos.mod.drug <- model.matrix(~ as.factor(Treatment), data = pos.data.pheno)
pos.mod0 <- model.matrix(~ 1, data = pos.data.pheno)
pos.sv <- sva(pos.data.for.sva, pos.mod.drug, pos.mod0)
# method 2
pos.d.sv.test <- cbind(pos.mod.drug, pos.sv$sv)  
colnames(pos.d.sv.test) <- c("cntrl", "DRUGvsCNTRL", "S1", "S2")
pos.top.table.test <- lmFit(pos.data.for.sva, pos.d.sv.test) %>% 
  eBayes() %>% 
  topTable(coef = "DRUGvsCNTRL", adjust = "bonferroni", p.value = 0.05, n = nrow(pos.data.for.sva))
pos.top.w.info <- pos.top.table.test %>% 
    rownames_to_column("compound_short") %>% 
    mutate(
      drug_div_cntrl = round(2 ^ logFC, 2),
      change_w_drug = ifelse(drug_div_cntrl < 1, "down", "up")
      ) %>% 
    filter(drug_div_cntrl > 1.2 | drug_div_cntrl < 0.83) %>%  
    arrange(change_w_drug, desc(drug_div_cntrl))
pos.top.w.info %>% 
  select(compound_short, change_w_drug, drug_div_cntrl)
```


```{r fig.width = 8, fig.height=10, echo=FALSE, comment=NA}
pos.surr.var <- as.data.frame(pos.sv$sv)
colnames(pos.surr.var) <- c("S1", "S2")
pos.gathered <- pos.noNA %>%
  filter(Group == "sample") %>% 
  bind_cols(pos.surr.var) %>% 
  select(Samples, Treatment, S1:S2, starts_with("ANPpC")) %>% 
  gather(key = "Compound", value = "Abundance", ANPpC1:ANPpC98)
pos.nested <- pos.gathered %>% 
  group_by(Compound) %>% 
  nest() %>% 
  mutate(model = map(data, ~lm(Abundance ~ S1 + S2, data = .))) %>% 
  mutate(augment_model = map(model, augment))
pos.modSV.resid <- pos.nested %>% 
  unnest(data, augment_model) %>% 
  select(Samples, Treatment, Compound, .resid) %>% 
  spread(Compound, .resid)
pos.modSV.resid %>% 
  select(Samples, one_of(pos.top.w.info$compound_short)) %>% 
    HeatmapPrepAlt("ANPpC") %>% 
    t() %>% 
    heatmaply(
      colors = viridis(n = 10, option = "magma"), 
      xlab = "Samples", ylab = "Compounds",
      main = "Statistically significant compounds\nPositive Mode",
      margins = c(50, 50, 75, 30),
      k_col = 2, k_row = 2
      )
```
  
The positive mode dataset results echo and compliment the negative mode results. From here, the compound identities can be used to try and explain what is actually going on. This step usually involves a lot of research and background reading, but there are tools such as [MetaboAnalyst](http://www.metaboanalyst.ca/) that are really popular for figuring out which metabolic pathways were impacted.

  
# Interpretation


Please excuse the secrecy, but this data is unpublished (although hopefully not for long?) But I have selected a portion of the statistically significant compounds for interpretation from the 3 following metabolic pathways:

* Pentose Phosphate Pathway (PPP) - typically anabolic pathway that uses sugars and glycolysis intermediates to synthesize the ribose backbone for nucleotide biosynthesis and to produce the reducing molecule NADPH
* Purine Metabolism - the biosynthesis and breakdown of the nucleotides ATP/dATP and GTP/dGTP, the building blocks of DNA and RNA, as well as molecules that play vital roles in energy homeostasis and signaling
* Pyrimidine Metabolism - the biosynthesis and breakdown of the nucleotides dTTP, UTP, and CTP/dCTP, also the building blocks of DNA and RNA

One of the interesting things I noted was that the drug had a profound effect on decreasing the abundance of a number of molecules involved in these pathways.  

```{r comment=NA}
# Hits file
pathway.info <- read_csv("./data/pathway_info.csv")
# give a name to some of the hits:
glimpse(pathway.info)
# pathway numbers:
table(pathway.info$Pathway)
hit.list <- neg.top.w.info %>% 
  mutate(Mode = "neg") %>% 
  bind_rows(
    pos.top.w.info %>% 
    mutate(Mode = "pos")
  ) %>% 
  as.tibble() %>% 
  select(compound_short, drug_div_cntrl:Mode) %>% 
  inner_join(
    pathway.info, by = "compound_short"
  ) 
glimpse(hit.list)
```


## Nucleotide Metabolism

The following section groups the statistically significant hits by pathway (although there is some overlap of members between pathways), and is mostly a lot of formatting for publication-quality plots. I chose boxplots to show the distribution of the data but also overlaid them with the individual data points to make all of the data visible.

```{r nuc_metab_plots, comment=NA}
### Purine Metabolism ###
purine.plot.order <- pathway.info %>%
  filter(Pathway == "Purine") %>% 
  mutate(plot_order = factor(Name, levels = Name))
purine.data <- neg.modSV.resid %>% 
  inner_join(pos.modSV.resid %>% select(-Treatment), by = "Samples") %>% 
  select(Samples:Treatment, one_of(purine.plot.order$compound_short)) 
purine.data %>% 
  gather(key = "compound_short", value = "Abundance", -Samples, -Treatment) %>% 
  inner_join(
    purine.plot.order %>% 
      filter(compound_full != "Aspartic Acid" & compound_full != "Ribose 5-Phosphate"), 
    by = "compound_short"
    ) %>%
  ggplot(aes(plot_order, Abundance, color = Treatment)) +
  geom_boxplot(position = position_dodge(0.8)) +
  geom_jitter(size = 2, alpha = 0.5, position = position_dodge(0.8)) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    panel.background = element_rect(fill = "gray90")
    ) +
  xlab("Compound (Mode)") +
  ylab("Residual Abundance") +
 ggtitle("Residual Abundance by Treatment\nPurine Metabolism\nStatistically Significant Compounds") +
  scale_color_manual(values = c("#56B4E9", "#E69F00"), labels = c("Control", "Drug")) +
  ylim(-4, 4)

### Pyrimidine Metabolism ###
pyrimidine.plot.order <- pathway.info %>% 
  filter(Pathway == "Pyrimidine") %>% 
  mutate(plot_order = factor(Name, levels = Name))
pyrimidine.data <- neg.modSV.resid %>% 
  inner_join(pos.modSV.resid %>% select(-Treatment), by = "Samples") %>% 
  select(Samples:Treatment, one_of(pyrimidine.plot.order$compound_short))
pyrimidine.data %>% 
  gather(key = "compound_short", value = "Abundance", -Samples, -Treatment) %>% 
  inner_join(
    pyrimidine.plot.order %>% 
      filter(compound_full != "Ribose 5-Phosphate"), by = "compound_short") %>%
  ggplot(aes(plot_order, Abundance, color = Treatment)) +
  geom_boxplot(position = position_dodge(0.8)) +
  geom_jitter(size = 2, alpha = 0.5, position = position_dodge(0.8)) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    panel.background = element_rect(fill = "gray90")
    ) +
  xlab("Compound (Mode)") +
  ylab("Residual Abundance") +
  ggtitle("Residual Abundance by Treatment\nPyrimidine Metabolism\nStatistically Significant Compounds") +
  scale_color_manual(values = c("#56B4E9", "#E69F00"), labels = c("Control", "Drug")) +
  ylim(-2, 2)

### Pentose Phosphate Pathway ###
ppp.plot.order <- pathway.info %>% 
  filter(Pathway == "PPP") %>% 
  mutate(plot_order = factor(Name, levels = Name))
ppp.data <- neg.modSV.resid %>% 
  inner_join(pos.modSV.resid %>% select(-Treatment), by = "Samples") %>% 
  select(Samples:Treatment, one_of(ppp.plot.order $compound_short))
ppp.data %>% 
  gather(key = "compound_short", value = "Abundance", -Samples, -Treatment) %>% 
  inner_join(ppp.plot.order, by = "compound_short") %>%
  ggplot(aes(plot_order, Abundance, color = Treatment)) +
  geom_boxplot(position = position_dodge(0.8)) +
  geom_jitter(size = 2, alpha = 0.5, position = position_dodge(0.8)) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    panel.background = element_rect(fill = "gray90")
    ) +
  xlab("Compound (Mode)") +
  ylab("Residual Abundance") +
  ggtitle("Residual Abundance by Treatment Group\nPPP Metabolism\nStatistically Significant Compounds") +
  scale_color_manual(values = c("#56B4E9", "#E69F00"), labels = c("Control", "Drug")) +
  ylim(-1.5, 1.5) +
  scale_x_discrete(labels = c("Glucose\n6-Phosphate", "Ribose", "Deoxyribose", "Glyceraldehyde\n3-Phosphate (Neg)", "Glyceraldehyde\n3-Phosphate (Pos)", "Ribose\n5-Phosphate", "Sedoheptulose\n7-Phosphate"))
```


And that's that. Thanks for reading!

# Session Info

Lastly, session info:

```{r session_info, comment=NA}
sessionInfo()
```

